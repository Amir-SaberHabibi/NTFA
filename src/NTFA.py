import streamlit as st
import pandas as pd
import numpy as np
import networkx as nx
import plotly.graph_objects as go
import time
import os

def draw_graph(G, pos, path=None):
    edge_x = []
    edge_y = []
    edge_text = []

    for edge in G.edges(data=True):
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x += (x0, x1, None)
        edge_y += (y0, y1, None)
        edge_text.append(f"{edge[0]} → {edge[1]}: {edge[2]['weight']}")

    edge_trace = go.Scatter(
        x=edge_x,
        y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='text',
        mode='lines',
        text=edge_text
    )

    path_edge_x = []
    path_edge_y = []
    path_edge_text = []

    if path:
        for u, v in zip(path[:-1], path[1:]):
            x0, y0 = pos[u]
            x1, y1 = pos[v]
            path_edge_x += (x0, x1, None)
            path_edge_y += (y0, y1, None)
            path_edge_text.append(f"{u} → {v}: {G[u][v]['weight']}")

    path_edge_trace = go.Scatter(
        x=path_edge_x,
        y=path_edge_y,
        line=dict(width=2, color='red'),
        hoverinfo='text',
        mode='lines',
        text=path_edge_text
    )

    node_x = []
    node_y = []
    node_color = []

    for node in G.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)
        node_color.append('skyblue')

    if path:
        for node in path:
            idx = list(G.nodes()).index(node)
            node_color[idx] = 'red'

        start_idx = list(G.nodes()).index(path[0])
        end_idx = list(G.nodes()).index(path[-1])
        node_color[start_idx] = 'green'
        node_color[end_idx] = 'blue'

    node_trace = go.Scatter(
        x=node_x,
        y=node_y,
        mode='markers+text',
        text=list(G.nodes()),
        textposition='top center',
        marker=dict(
            showscale=False,
            color=node_color,
            size=10,
            line_width=2
        )
    )

    fig = go.Figure(data=[edge_trace, path_edge_trace, node_trace],
                    layout=go.Layout(
                        title='Network Graph',
                        showlegend=False,
                        hovermode='closest',
                        margin=dict(b=20, l=5, r=5, t=40),
                        annotations=[dict(
                            text="shortest path highlighted in red",
                            showarrow=False,
                            xref="paper", yref="paper",
                            x=0.005, y=-0.002
                        )],
                        xaxis=dict(showgrid=False, zeroline=False),
                        yaxis=dict(showgrid=False, zeroline=False)
                    ))

    return fig


def network_traffic_flow_analysis():
    st.title("Network Traffic Flow Analysis")
    st.markdown(""" For analysis puproses of a sample dataset, we have used [Unicauca Network Flows Dataset](https://www.kaggle.com/datasets/jsrojas/labeled-network-traffic-flows-114-applications) to achieve our goal, that is to see a proper demostration of Dijkstra's Algorithm for network traffic flow analysis.""")
    st.markdown("""
    ## Dataset Feature Selection

    In order to maintain a proper usability of the dataset for the project's use case, three features of **src_ip**, **dst_ip**, and **octetTotalCount** are selected for task accomplishment:

    - **`src_ip`**: Source IP address.
    - **`dst_ip`**: Destination IP address.
    - **`octetTotalCount`**: Exchanged data volume.
    """)    
    
    st.markdown(
        """ ## **About Dataset**

### **Context**
The presented data was collected in the network from Universidad Del Cauca, Popayán, Colombia by performing packet captures at different hours, during morning and afternoon, over different days between April and June of 2019. A total of 2,704,839 flow instances were collected and are currently stored in a CSV (Comma Separated Values) file.

### **Content**
This dataset contains **50 features**. Each instance holds the information of an IP flow generated by a network device i.e., source and destination IP addresses, ports, flow durations, interarrival times, packet sizes, and layer 7 protocol (application) used on that flow as the class. Most of the attributes are numeric type but there are also nominal types.

The dataset presented here was obtained by processing the different PCAP files with Flow Labeler, an application developed to perform the aggregation of packets into flows, the calculation of flow statistics, and the labeling of the flows with their respective application through the nDPI library.

 """)
    
    
    # dataset path
    csv_file_path = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', 'dataset', 'sparse_matrix.csv'))

    df = pd.read_csv(csv_file_path, index_col=0)
    matrix = df.replace('inf', np.inf).values

    G = nx.DiGraph()

    for node in df.index:
        G.add_node(node)

    for i, src in enumerate(df.index):
        for j, dst in enumerate(df.columns):
            if matrix[i, j] != np.inf:
                G.add_edge(src, dst, weight=matrix[i, j])

    pos = nx.circular_layout(G)

    # showing the initial graph
    st.header("Initial Network Graph")
    fig = draw_graph(G, pos)
    st.plotly_chart(fig)

    st.markdown("<hr>", unsafe_allow_html=True)

    # node selection
    st.header("Select Source and Destination Nodes")
    nodes = list(G.nodes())
    start_node = st.selectbox(f"Select the :green[source] node", nodes)
    end_node = st.selectbox(f"Select the :blue[destination] node", nodes)

    if st.button("Compute Shortest Path", key="compute_shortest_path_1"):
        message = st.empty()
        if start_node == end_node:
            message.error("Source and destination nodes cannot be the same. Please select different nodes.")
            time.sleep(2)
            message.empty()
        else:
            with st.spinner(text='In progress'):
                time.sleep(1)
                message.success('Done!')
            # time.sleep(3)
            message.empty()
            try:
                path = nx.single_source_dijkstra_path(G, start_node)[end_node]
                cost = nx.single_source_dijkstra_path_length(G, start_node)[end_node]

                st.header("Shortest Path in the Network Graph")
                fig = draw_graph(G, pos, path)
                st.plotly_chart(fig)

                st.markdown("<hr>", unsafe_allow_html=True)

                st.markdown(f"Shortest path from `{start_node}` to `{end_node}`:")

                path_edges = [(path[i], path[i+1], G[path[i]][path[i+1]]['weight']) for i in range(len(path)-1)]
                path_df = pd.DataFrame(path_edges, columns=["Source", "Destination", "Weight"])

                st.markdown('<div style="display: flex; justify-content: center;">', unsafe_allow_html=True)
                st.write(path_df)
                st.markdown('</div>', unsafe_allow_html=True)

                st.markdown(f'<h2>Total Cost: {cost}</h2>', unsafe_allow_html=True)

            except nx.NetworkXNoPath:
                st.write(f"No path exists between {start_node} and {end_node}.")

    st.markdown("<hr>", unsafe_allow_html=True)

if __name__ == "__main__":
    network_traffic_flow_analysis()
